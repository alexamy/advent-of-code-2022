// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Belt_Int from "rescript/lib/es6/belt_Int.js";
import * as Caml_obj from "rescript/lib/es6/caml_obj.js";
import * as Belt_Array from "rescript/lib/es6/belt_Array.js";
import * as Belt_Option from "rescript/lib/es6/belt_Option.js";

var isHigherThan = Caml_obj.greaterequal;

function getDimensions(trees) {
  var rows = trees.length;
  var cols = Belt_Option.getWithDefault(Belt_Array.get(trees, 0), []).length;
  return [
          rows,
          cols
        ];
}

function isAtEdge(trees, param) {
  var col = param[1];
  var row = param[0];
  var match = getDimensions(trees);
  var isRowEdge = row === 0 || row === (match[0] - 1 | 0);
  var isColEdge = col === 0 || col === (match[1] - 1 | 0);
  if (isRowEdge) {
    return true;
  } else {
    return isColEdge;
  }
}

function getTree(trees, param) {
  return Belt_Array.get(Belt_Option.getWithDefault(Belt_Array.get(trees, param[0]), []), param[1]);
}

function getNeighbours(trees, param, offset) {
  var col = param[1];
  var row = param[0];
  var top = getTree(trees, [
        row - offset | 0,
        col
      ]);
  var left = getTree(trees, [
        row,
        col - offset | 0
      ]);
  var bottom = getTree(trees, [
        row + offset | 0,
        col
      ]);
  var right = getTree(trees, [
        row,
        col + offset | 0
      ]);
  return {
          top: top,
          left: left,
          bottom: bottom,
          right: right
        };
}

var Trees = {
  isHigherThan: isHigherThan,
  getDimensions: getDimensions,
  isAtEdge: isAtEdge,
  getTree: getTree,
  getNeighbours: getNeighbours
};

function isVisibleInner(trees, _param, _offset) {
  while(true) {
    var param = _param;
    var offset = _offset;
    var col = param[1];
    var row = param[0];
    var match = getNeighbours(trees, [
          row,
          col
        ], offset);
    var tree = Belt_Option.getExn(getTree(trees, [
              row,
              col
            ]));
    var neighbours = [
      match.top,
      match.left,
      match.bottom,
      match.right
    ];
    var isAll = neighbours.every(Belt_Option.isNone);
    var someHigher = neighbours.some((function(tree){
        return function (other) {
          return Belt_Option.getWithDefault(Belt_Option.map(other, (function (__x) {
                            return Caml_obj.greaterequal(__x, tree);
                          })), false);
        }
        }(tree)));
    if (isAll) {
      return true;
    }
    if (someHigher) {
      return false;
    }
    _offset = offset + 1 | 0;
    _param = [
      row,
      col
    ];
    continue ;
  };
}

function isVisible(trees, param) {
  var col = param[1];
  var row = param[0];
  if (isAtEdge(trees, [
          row,
          col
        ])) {
    return true;
  } else {
    return isVisibleInner(trees, [
                row,
                col
              ], 1);
  }
}

function start(trees) {
  var visibility = trees.map(function (row, rowIdx) {
        return row.map(function (param, colIdx) {
                    return isVisible(trees, [
                                rowIdx,
                                colIdx
                              ]);
                  });
      });
  return Belt_Array.flatMap(visibility, (function (x) {
                  return x;
                })).filter(function (x) {
              return x === true;
            }).length;
}

var Calculate = {
  isVisibleInner: isVisibleInner,
  isVisible: isVisible,
  start: start
};

function toNumber(n) {
  return Belt_Option.getExn(Belt_Int.fromString(n));
}

function makeLine(line) {
  return line.split("").map(toNumber);
}

function make(input) {
  return input.split("\n").map(makeLine);
}

var Process = {
  toNumber: toNumber,
  makeLine: makeLine,
  make: make
};

function solve1(input) {
  return start(make(input));
}

function solve2(_input) {
  
}

export {
  Trees ,
  Calculate ,
  Process ,
  solve1 ,
  solve2 ,
}
/* No side effect */
