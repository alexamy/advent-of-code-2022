// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Belt_Int from "rescript/lib/es6/belt_Int.js";
import * as Caml_obj from "rescript/lib/es6/caml_obj.js";
import * as Belt_Array from "rescript/lib/es6/belt_Array.js";
import * as Belt_Option from "rescript/lib/es6/belt_Option.js";

function getTree(trees, row, col) {
  return Belt_Array.getExn(Belt_Array.getExn(trees, row), col);
}

function isVisible(trees, _param, _param$1) {
  while(true) {
    var param = _param;
    var param$1 = _param$1;
    var right = param$1[3];
    var bottom = param$1[2];
    var left = param$1[1];
    var top = param$1[0];
    var col = param[1];
    var row = param[0];
    var isEnd = top === row && left === col && bottom === row && right === col;
    var lastRow = trees.length - 1 | 0;
    var lastCol = Belt_Array.getExn(trees, 0).length - 1 | 0;
    var isEdge = row === 0 || col === 0 || row === lastRow || col === lastCol;
    var tree = getTree(trees, row, col);
    var isTopHigher = top !== row && Caml_obj.greaterequal(getTree(trees, top, col), tree);
    var isLeftHigher = left !== col && Caml_obj.greaterequal(getTree(trees, row, left), tree);
    var isBottomHigher = bottom !== row && Caml_obj.greaterequal(getTree(trees, bottom, col), tree);
    var isRightHigher = right !== col && Caml_obj.greaterequal(getTree(trees, row, right), tree);
    var isSomeHigher = isTopHigher || isLeftHigher || isBottomHigher || isRightHigher;
    var topNext = Math.min(top + 1 | 0, row);
    var leftNext = Math.min(left + 1 | 0, col);
    var bottomNext = Math.max(bottom - 1 | 0, row);
    var rightNext = Math.max(right - 1 | 0, row);
    if (isEnd) {
      return true;
    }
    if (isEdge) {
      return true;
    }
    if (isSomeHigher) {
      return false;
    }
    _param$1 = [
      topNext,
      leftNext,
      bottomNext,
      rightNext
    ];
    _param = [
      row,
      col
    ];
    continue ;
  };
}

function start(trees) {
  var visibility = trees.map(function (row, rowIdx) {
        return row.map(function (param, colIdx) {
                    var lastRow = trees.length - 1 | 0;
                    var lastCol = Belt_Array.getExn(trees, 0).length - 1 | 0;
                    return isVisible(trees, [
                                rowIdx,
                                colIdx
                              ], [
                                0,
                                0,
                                lastRow,
                                lastCol
                              ]);
                  });
      });
  return Belt_Array.flatMap(visibility, (function (x) {
                  return x;
                })).filter(function (x) {
              return x === true;
            }).length;
}

var Calculate = {
  getTree: getTree,
  isVisible: isVisible,
  start: start
};

function toNumber(n) {
  return Belt_Option.getExn(Belt_Int.fromString(n));
}

function makeLine(line) {
  return line.split("").map(toNumber);
}

function make(input) {
  return input.split("\n").map(makeLine);
}

var Process = {
  toNumber: toNumber,
  makeLine: makeLine,
  make: make
};

function solve1(input) {
  return start(make(input));
}

function solve2(_input) {
  
}

export {
  Calculate ,
  Process ,
  solve1 ,
  solve2 ,
}
/* No side effect */
